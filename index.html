<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Braze to MoEngage Migration Guide</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="threejs-canvas"></canvas>
    
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <canvas id="loading-canvas"></canvas>
        <div class="loading-overlay">
            <div class="loading-content">
                <div class="loading-logo">
                    <div class="loading-icon">âš¡</div>
                    <div class="loading-text">MIGRATING</div>
                </div>
                <div class="loading-progress">
                    <div class="progress-bar">
                        <div class="progress-fill"></div>
                        <div class="progress-glow"></div>
                    </div>
                    <div class="loading-percentage">0%</div>
                </div>
                <div class="loading-subtitle">Initializing documentation matrix...</div>
                <div class="loading-status">
                    <div class="status-dot"></div>
                    <div class="status-text">Establishing connection...</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="homepage-container">
        <div class="hero-content">
            <div class="glitch-wrapper">
                <h1 class="homepage-title glitch" data-text="Migration Protocol">Migration Protocol</h1>
            </div>
            <h2 class="subtitle-main">Braze â†’ MoEngage</h2>
            <p class="homepage-subtitle">
                <span class="typewriter" id="typewriter-text"></span>
                <span class="cursor">|</span>
            </p>
            
            <div class="stats-container">
                <div class="stat-item">
                    <div class="stat-number" data-target="2">0</div>
                    <div class="stat-label">Platforms</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" data-target="100">0</div>
                    <div class="stat-label">Success Rate</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" data-target="24">0</div>
                    <div class="stat-label">Fields Mapped</div>
                </div>
            </div>
            
            <div class="navigation-buttons">
                <a href="email.html" class="nav-button email-btn">
                    <div class="btn-content">
                        <div class="btn-icon">ðŸ“§</div>
                        <div class="btn-text">
                            <span class="btn-title">Email Campaigns</span>
                            <span class="btn-subtitle">Field mapping & transformations</span>
                        </div>
                    </div>
                    <div class="btn-glow"></div>
                </a>
                <a href="push.html" class="nav-button push-btn">
                    <div class="btn-content">
                        <div class="btn-icon">ðŸ””</div>
                        <div class="btn-text">
                            <span class="btn-title">Push Notifications</span>
                            <span class="btn-subtitle">Multi-platform migration</span>
                        </div>
                    </div>
                    <div class="btn-glow"></div>
                </a>
            </div>
            
            <div class="tech-stack">
                <div class="tech-item">Braze API</div>
                <div class="tech-separator">â†’</div>
                <div class="tech-item">Field Mapping</div>
                <div class="tech-separator">â†’</div>
                <div class="tech-item">MoEngage SDK</div>
            </div>
        </div>
        
        <div class="scroll-indicator">
            <div class="mouse">
                <div class="wheel"></div>
            </div>
            <div class="scroll-text">Scroll to explore</div>
        </div>
    </div>

    <script>
        // Three.js Background Animation
        let scene, camera, renderer, particles;
        
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('threejs-canvas'), alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Create particles
            const geometry = new THREE.BufferGeometry();
            const particleCount = 1000;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 2000;
                positions[i + 1] = (Math.random() - 0.5) * 2000;
                positions[i + 2] = (Math.random() - 0.5) * 2000;
                
                colors[i] = Math.random() * 0.5 + 0.5; // R
                colors[i + 1] = Math.random() * 0.3 + 0.7; // G
                colors[i + 2] = 1; // B
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            camera.position.z = 500;
            
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            particles.rotation.x += 0.001;
            particles.rotation.y += 0.002;
            
            renderer.render(scene, camera);
        }
        
        // Typewriter effect
        const texts = [
            "Technical field mapping documentation for Email and Push Notification campaigns.",
            "Comprehensive guide with detailed mappings, transformations, and implementation examples.",
            "Successfully migrate your campaigns between platforms with confidence."
        ];
        let textIndex = 0;
        let charIndex = 0;
        let isDeleting = false;
        const typewriterElement = document.getElementById('typewriter-text');
        
        function typeWriter() {
            const currentText = texts[textIndex];
            
            if (isDeleting) {
                typewriterElement.textContent = currentText.substring(0, charIndex - 1);
                charIndex--;
            } else {
                typewriterElement.textContent = currentText.substring(0, charIndex + 1);
                charIndex++;
            }
            
            let timeout = isDeleting ? 50 : 100;
            
            if (!isDeleting && charIndex === currentText.length) {
                timeout = 2000;
                isDeleting = true;
            } else if (isDeleting && charIndex === 0) {
                isDeleting = false;
                textIndex = (textIndex + 1) % texts.length;
            }
            
            setTimeout(typeWriter, timeout);
        }
        
        // Counter animation
        function animateCounters() {
            const counters = document.querySelectorAll('.stat-number');
            counters.forEach(counter => {
                const target = parseInt(counter.getAttribute('data-target'));
                const increment = target / 100;
                let current = 0;
                
                const updateCounter = () => {
                    if (current < target) {
                        current += increment;
                        counter.textContent = Math.ceil(current);
                        setTimeout(updateCounter, 20);
                    } else {
                        counter.textContent = target;
                    }
                };
                updateCounter();
            });
        }
        
        // Initialize
        window.addEventListener('load', () => {
            initThreeJS();
            setTimeout(typeWriter, 1000);
            setTimeout(animateCounters, 2000);
            
            // Add loading screen functionality
            setupLoadingScreen();
        });
        
        // Loading Screen Functionality with 3D Animation
        let loadingScene, loadingCamera, loadingRenderer, loadingObjects, dataSphere, dataFlow;
        
        function initLoadingScreen() {
            const loadingCanvas = document.getElementById('loading-canvas');
            
            // Initialize Three.js for loading screen
            loadingScene = new THREE.Scene();
            loadingCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            loadingRenderer = new THREE.WebGLRenderer({ canvas: loadingCanvas, alpha: true, antialias: true });
            loadingRenderer.setSize(window.innerWidth, window.innerHeight);
            loadingRenderer.setClearColor(0x000000, 0.9);
            
            // Create central data sphere
            const sphereGeometry = new THREE.IcosahedronGeometry(15, 2);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x00d4ff,
                wireframe: true,
                transparent: true,
                opacity: 0.6
            });
            dataSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            loadingScene.add(dataSphere);
            
            // Create orbiting data nodes
            loadingObjects = new THREE.Group();
            for (let i = 0; i < 50; i++) {
                const nodeGeometry = new THREE.OctahedronGeometry(0.5);
                const nodeMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.6 + Math.random() * 0.3, 0.8, 0.7),
                    transparent: true,
                    opacity: 0.8
                });
                
                const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                const radius = 25 + Math.random() * 40;
                const angle = (i / 50) * Math.PI * 2;
                const heightOffset = (Math.random() - 0.5) * 30;
                
                node.position.set(
                    Math.cos(angle) * radius,
                    heightOffset,
                    Math.sin(angle) * radius
                );
                
                node.userData = { 
                    radius: radius, 
                    angle: angle, 
                    speed: 0.01 + Math.random() * 0.02,
                    originalY: heightOffset
                };
                
                loadingObjects.add(node);
            }
            loadingScene.add(loadingObjects);
            
            // Create data flow lines
            dataFlow = new THREE.Group();
            for (let i = 0; i < 100; i++) {
                const points = [];
                const startRadius = 20;
                const endRadius = 60;
                const angle = (i / 100) * Math.PI * 2;
                
                for (let j = 0; j <= 20; j++) {
                    const progress = j / 20;
                    const currentRadius = startRadius + (endRadius - startRadius) * progress;
                    const currentAngle = angle + progress * Math.PI * 0.5;
                    const height = Math.sin(progress * Math.PI) * 15;
                    
                    points.push(new THREE.Vector3(
                        Math.cos(currentAngle) * currentRadius,
                        height,
                        Math.sin(currentAngle) * currentRadius
                    ));
                }
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xff3366,
                    transparent: true,
                    opacity: 0.4
                });
                
                const line = new THREE.Line(lineGeometry, lineMaterial);
                line.userData = { phase: Math.random() * Math.PI * 2 };
                dataFlow.add(line);
            }
            loadingScene.add(dataFlow);
            
            // Add ambient lighting effect
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            loadingScene.add(ambientLight);
            
            loadingCamera.position.z = 80;
            loadingCamera.position.y = 20;
            loadingCamera.lookAt(0, 0, 0);
        }
        
        function animateLoadingScreen(progress = 0) {
            if (!loadingRenderer) return;
            
            requestAnimationFrame(() => animateLoadingScreen(progress));
            
            const time = Date.now() * 0.001;
            
            // Animate central sphere
            if (dataSphere) {
                dataSphere.rotation.x += 0.005;
                dataSphere.rotation.y += 0.01;
                dataSphere.scale.setScalar(1 + Math.sin(time * 2) * 0.1);
                
                // Change color based on progress
                const hue = 0.6 + (progress / 100) * 0.3;
                dataSphere.material.color.setHSL(hue, 0.8, 0.6);
            }
            
            // Animate orbiting nodes
            if (loadingObjects) {
                loadingObjects.children.forEach((node, index) => {
                    const userData = node.userData;
                    userData.angle += userData.speed;
                    
                    node.position.x = Math.cos(userData.angle) * userData.radius;
                    node.position.z = Math.sin(userData.angle) * userData.radius;
                    node.position.y = userData.originalY + Math.sin(time + index) * 3;
                    
                    node.rotation.x += 0.02;
                    node.rotation.y += 0.015;
                    
                    // Scale based on distance and progress
                    const distance = node.position.distanceTo(dataSphere.position);
                    const scale = 1 + (60 - distance) / 60 * 0.5 + (progress / 100) * 0.3;
                    node.scale.setScalar(scale);
                });
                
                loadingObjects.rotation.y += 0.002;
            }
            
            // Animate data flow
            if (dataFlow) {
                dataFlow.children.forEach((line, index) => {
                    line.userData.phase += 0.05;
                    const opacity = 0.2 + Math.sin(line.userData.phase) * 0.3;
                    line.material.opacity = Math.max(0, opacity);
                    
                    // Rotate data flow
                    line.rotation.y += 0.003 + index * 0.0001;
                });
                
                dataFlow.rotation.x += 0.001;
                dataFlow.rotation.y -= 0.002;
            }
            
            // Camera movement
            loadingCamera.position.x = Math.cos(time * 0.1) * 5;
            loadingCamera.position.y = 20 + Math.sin(time * 0.15) * 5;
            loadingCamera.lookAt(0, 0, 0);
            
            loadingRenderer.render(loadingScene, loadingCamera);
        }
        
        function setupLoadingScreen() {
            const navButtons = document.querySelectorAll('.nav-button');
            const loadingScreen = document.getElementById('loading-screen');
            const progressFill = document.querySelector('.progress-fill');
            const progressGlow = document.querySelector('.progress-glow');
            const loadingPercentage = document.querySelector('.loading-percentage');
            const loadingSubtitle = document.querySelector('.loading-subtitle');
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.querySelector('.status-text');
            
            const loadingMessages = [
                "Initializing documentation matrix...",
                "Parsing field mappings...",
                "Compiling transformation rules...",
                "Loading 3D interface...",
                "Establishing secure connection...",
                "Ready to migrate!"
            ];
            
            const statusMessages = [
                "Connecting to Braze API...",
                "Authenticating credentials...",
                "Mapping data structures...",
                "Validating transformations...",
                "Preparing MoEngage payload...",
                "Migration complete!"
            ];
            
            navButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetUrl = button.getAttribute('href');
                    
                    // Initialize and show loading screen
                    initLoadingScreen();
                    loadingScreen.classList.add('active');
                    animateLoadingScreen(0);
                    
                    // Animate progress bar - 2 second duration
                    let progress = 0;
                    let messageIndex = 0;
                    const totalDuration = 2000; // 2 seconds
                    const updateInterval = 50; // Update every 50ms
                    const totalSteps = totalDuration / updateInterval;
                    const progressIncrement = 100 / totalSteps;
                    
                    const progressInterval = setInterval(() => {
                        progress += progressIncrement;
                        
                        if (progress >= 100) {
                            progress = 100;
                            clearInterval(progressInterval);
                            
                            // Navigate after completion
                            setTimeout(() => {
                                window.location.href = targetUrl;
                            }, 200);
                        }
                        
                        // Update progress visuals
                        progressFill.style.width = progress + '%';
                        progressGlow.style.width = progress + '%';
                        loadingPercentage.textContent = Math.floor(progress) + '%';
                        
                        // Update loading message
                        const newMessageIndex = Math.floor((progress / 100) * loadingMessages.length);
                        if (newMessageIndex !== messageIndex && newMessageIndex < loadingMessages.length) {
                            messageIndex = newMessageIndex;
                            loadingSubtitle.textContent = loadingMessages[messageIndex];
                            statusText.textContent = statusMessages[messageIndex];
                            
                            // Animate status dot
                            statusDot.style.animationDuration = `${0.5 + Math.random() * 0.5}s`;
                        }
                        
                        // Update 3D animation with progress
                        animateLoadingScreen(progress);
                        
                    }, updateInterval);
                });
            });
            
            // Handle resize for loading screen
            window.addEventListener('resize', () => {
                if (loadingRenderer) {
                    loadingCamera.aspect = window.innerWidth / window.innerHeight;
                    loadingCamera.updateProjectionMatrix();
                    loadingRenderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Mouse movement effect
        document.addEventListener('mousemove', (e) => {
            const mouseX = e.clientX / window.innerWidth - 0.5;
            const mouseY = e.clientY / window.innerHeight - 0.5;
            
            if (particles) {
                particles.rotation.x = mouseY * 0.1;
                particles.rotation.y = mouseX * 0.1;
            }
        });
    </script>
</body>
</html>